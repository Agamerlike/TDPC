# Typical DP Contest

# A
i問目までの問題を解いた時に取ることができる得点を記録する。一度取ることができることが分かった得点がその後の全ての問題を解いた時に取れなくなってしまうというケースはこの問題では存在しないため0番目（何も解かない）から出発して順番に解いていった場合の得点を記録していけばよい。

ここで1次元のDPを考えた。dp[i]は得点iを取ることができる問題の組み合わせが存在するかどうかの真理値である。ここでk問目までの問題を解いたとき（つまりこの時点での得点の最大値はk問目まですべて解けた場合）のdp[]についての処理を詳しく考えると、dp[]の中身を0からたどるか最大値からたどるかの2通りの処理が考えられる。

しかし、前者の場合、そのループ内でfalseからtrueに変わった（つまり直前のループでは作ることのできなかった）得点を再度参照してしまい間違った値をtrueにしてしまうので、不適切である。このことを防ぐためにもdp[j][i]として、j番目までの問題を解いた時に得点iを取ることができる問題の組み合わせが存在するかどうかの真理値とし、一度更新してしまったところを参照しないようにする（更新の際には過去の情報のみ参照する）などが考えられる。また、このような問題が見えにくくなってしまうので**DPにおいてはソートなどによって入力値の順序を変えてはいけない。（これは他のプログラムの場合についても同様で、計算量がO記法で少なくなるようなことがない場合にむやみにいじってはいけない）**

後者の場合では、1次元DPによってきれいに記述できる。この問題においては新しくfalseからtrueになる得点は派生元よりも常に点数が高くなるためである。例えば問題の得点に負の数も考えられるケースにおいては、1次元DPでの記述は不可能である。

# B
2つの山がそれぞれ残りi個、j個のときのすぬけ君が取る点数を記録する。


# D
最初目の和と誤読していて大量に時間を消費。その後積で書き直すもこちらもgoogleに突っ込んだ計算式を誤読してRE（6^100<10^8になるわけないだろボケカス）。力尽きた。

### 追記（解説見た）
素因数分解。倍数と来たら素因数分解は基本（できない）。

とはいっても迷走しまくった。桁数の見積もり甘くて初めてMLE出したり。無限にバグらせたり。MLEが出た場合はi番目の部分を削るのではなく問題条件から使わない部分を削っていくほうが賢い。i番目削って次元減らすとなぜかどこかバグるので。